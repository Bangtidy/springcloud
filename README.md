# SpringCloud

创建父子工程，约定>配置>编码

创建moudle,改pom，编写配置yml，主启动类、业务类



由restTemplate调用远程api



## **Eureka**

### eureka服务注册中心

![img](photo/eureka服务注册中心.png)

**Eureka包含两个组件:Eureka Server和Eureka Client**

Eureka Server提供**服务注册**服务

各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。

EurekaClient通过**注册中心进行访问**

它是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒)



### eureka集群

![img](photo/eureka集群.png)

**服务注册**：将服务信息注册进注册中心

**服务发现**：从注册中心上获取服务信息

**实质**：存key服务命取value闭用地址

执行流程：

1先启动eureka注主册中心

2启动服务提供者payment支付服务

3支付服务启动后会把自身信息(比服务地址L以别名方式注朋进eureka

4消费者order服务在需要调用接口时，使用服务别名去注册中心获取实际的RPC远程调用地址

5消费者导调用地址后，底层实际是利用HttpClient技术实现远程调用

6消费者实癸导服务地址后会缓存在本地jvm内存中，默认每间隔30秒更新—次服务调用地址



问题:微服务RPC远程服务调用最核心的是什么
高可用，试想你的注册中心只有一个only one，万一它出故障了，会导致整个为服务环境不可用。

解决办法：**搭建Eureka注册中心集群，实现负载均衡+故障容错**。

**互相注册，相互守望**。



#### 服务发现Discovery

通过discoveryClient可以发现eureka上注册的服务列表，还可以知道每个服务对应的实例信息等等。



#### 自我保护机制

默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例(默认90秒)。但是当网络分区故障发生(延时、卡顿、拥挤)时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时(可能发生了网络分区故障)，那么这个节点就会进入自我保护模式。
**在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例**。



## Zookeeper

zookeeper是一个分布式协调工具，可以实现**注册中心**功能。

利用Zookeeper替代Eureka作为注册中心，将服务注册进Zookeeper，作为一个有序号的临时节点，当服务宕机时，如果Zookeeper检测到该服务不可用时，会直接释放掉该节点。而eureka有自我保护机制，不会释放掉该服务。



## Consul

Consul是一套开源的分布式服务发现和配置管理系统，用Go语言开发。提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要**单独使用**，也可以一起使用以构建全方位的服务网格，总之Consul提供了一种完整的服务网格解决方案。

它具有很多优点。包括：基于raft协议，比较简洁；支持健康检查，同时支持HTTP和DNS协议支持跨数据中心的WAN集群提供图形界面跨平台，支持Linux、Mac、Windows。



能干嘛？

- **服务发现** - 提供HTTP和DNS两种发现方式。
- **健康监测** - 支持多种方式，HTTP、TCP、Docker、Shell脚本定制化
- **KV存储** - Key、Value的存储方式
- 多数据中心 - Consul支持多数据中心
- 可视化Web界面